
## HTTPS

#### HTTPS
HTTPS는 HTTP + SSL(혹은 TLS)로, HTTP프로토콜 아래에 보안계층인 SSL(Secure Sockets Layer)를 추가한 프로토콜이다.   
   
HTTPS는 HTTP메시지를 네트워크를 통해 전송하기전에, SSL계층을통해 모든 HTTP요청을 암호화 한다.   
HTTPS는 "암호"와 이를 푸는 "키"를 이용해 클라이언트와 서버서로를 인증하게 하고, 확인된 사용자만 정보를 얻을 수 있게한다.   
   
#### 목차
- 대칭키 암호법
- 공개키 암호법
- 대칭키 암호법과 공개키 암호법, SSL 핸드셰이크
- HTTPS 트랜잭션
- 디지털 인증서

#### 대칭키 암호법
대칭키 암호법은, 메시지 서버와 클라이언트가 하나의 키를 통해 메시지를 인코딩 디코딩하며, 주고받는것을 말한다.     
대칭키 암호법을 사용하려면, 우선 송신자와 수신자가 키를 교환해야한다. 또한 이렇게 교환된 키를 기억해야하며, 다른 쌍의 메시지가 노출되면 안되므로 각 쌍 마다 다른 키를 사용해야한다. 

#### 공개키 암호법
공개키 암호법은 인코딩과 디코딩에 각각 다른 키를 사용하는 암호법이다. 이때, 메시지 인코딩은 누구나 할수있지만, 디코딩은 서버만 할수있다. 이는, 클라이언트가 서버에  메시지를 송신하는 과정에서 메시지 탈취가 일어나도 해당 메시지의 내용을 알 수 없도록 해준다.

#### 대칭키 암호법과 공개키 암호법, SSL 핸드셰이크
공개키 암호법이 대칭키 암호법보다 항상 좋은것은 아니다. 공개키 암호법은 대칭키 암호법보다 계산이 느리다.   
따라서, 실제통신에는 우선 공개키 암호법으로 서로의 대칭키를 만들고, 이 후 부터는 대칭키를 이용해 통신한다. 대칭키를 만드는 SSL 핸드셰이킹 과정을 간단히 알아보자.   

1. 클라이언트가 서버에 사용가능한 암호 알고리즘들을 보낸다.

2. 서버는 클라이언트에게 인증서(디지털 인증서로 이 서버가 신뢰할수있는 서버인지 확인해준다.), 선택된 암호 알고리즘을 보낸다.
-- 이때, 인증서에는 메시지를 인코딩 할 수 있는 공개키가 포함되어 있다.

3. 클라이언트는 서버인증서를 통해 공개키를 얻고, 비밀정보를 암호화해서 서버에 전송한다.
이때, 클라이언트는 자신이 통신하고있는 서버가 올바른 서버인지 인증서를 통해 확인한다.

4. 서버와 클라이언트는 비밀정보를 통해 대칭키를 만든다.

#### HTTPS 트랜잭션

최종적으로 HTTPS 트랜잭션은 다음과 같이 만들어진다.

1. 서버와 클라이언트가 SSL 핸드셰이킹을 통해 서로의 대칭키를 만든다.
2. 클라이언트는 서버에 데이터를 요청할때, 1번에서 만든 대칭키를 이용해 메시지를 암호화한다.
3. 서버는 클라이언트의 요청을 대칭키를 통해 복호화하고, 다시 대칭키를 이용해 메시지를 암호화하여 응답한다.
4. 클라이언트는 서버의 암호화된 응답을 대칭키를 통해 복호화 한다.
 
#### 디지털 인증서
디지털 인증서는 크게, 다음과 같이 두가지로 나뉜다.
- 클라이언트 인증서
클라이언트가 서버에게 자신을 증명할때 사용
- 서버 인증서
서버가 클라이언트에게 자신을 증명할때 사용
   
클라이언트 인증서는 오늘날 많이 사용되지 않으므로, 서버인증서에 대해 설명하겠다.   
서버인증서는 다음과 같이 이루어져있다.
```
인증서 일련번호 : 35:DE:F4:CF
인증서 유효기간 : 2021년 9월 26일 월요일
사이트 조직이름 : Hello world
사이트의 DNS 호스트명 : www.HelloWorld.com
사이트의 공개키 : ~
인증서 발급자 이름 : RSA 데이터 보안
인증서 발급자 서명 : ~
```
앞서 말한것처럼, 클라이언트는 인증서를 검사하여 서버가 믿을만 한지 확인한다.     
- 날짜검사 : 클라이언트는 서버의 인증서 유효기간을 검사하여 해당 서버의 인증서 유효기간이 아직 지나지 않았는지 확인한다.

- 서명자 신뢰도 검사 : 디지털 인증서는 누구나 쉽게 발급할 수 있기 때문에, 모든 인증서가 신뢰할만한 것은 아니다. 따라서, 클라이언트는 디지털 인증서를 검사하여 해당 인증서에 서명한 서명자가 신뢰할만 한지 확인한다.

- 사이트 신원검사 : 인증서의 사이트 DNS 호스트명과 자신이 실제 통신하고있는 서버를 비교한다. 만약, 비교가 실패할경우 에러와 함께 커넥션을 끊는다.
