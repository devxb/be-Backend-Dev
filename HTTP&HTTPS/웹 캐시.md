## 웹 캐시

캐시는 자주 쓰이는 문서 사본을 저장한 HTTP 장치다.     
여기에는 캐시의 특징과 캐시를 사용했을때의 이점에 대해 서술하도록 하겠다.
- 캐시의 특징
- 캐시 저장위치
- 캐시 적중, 비적중, 재검사
- Cache-Control 헤더
---
#### 캐시의 특징
- 네트워크 병목을 줄여준다.   
많은 네트워크가 원격서버보다 로컬네트워크에 더 넓은 대역폭을 제공한다. 로컬네트워크에 저장된 캐시 사본을 가져옴으로써, 성능을 대폭 향상시킬수있다.

- 불필요한 데이터 전송을 줄인다.   
클라이언트들이 서버에 같은 문서를 요청할때마다, 서버는 중복된 문서를 클라이언트에게 제공한다. 첫번째 응답을 캐시에 보관하여, 불필요한 데이터 전송을 줄이고 원 서버의 부하를 줄일수있다.

- 거리로 인한 지연을 줄여준다.     
클라이언트와 서버의 물리적거리가 멀 경우, 빛의 속도 그 자체가 유의미한 지연을 유발한다. 캐시를 이용해 더 가까운 위치에서 문서를 제공한다면, 성능을 크게 향상시킬수있다.

---
#### 캐시 저장위치
캐시는 개인 전용 캐시와 다른사람과 함께 사용하는 공용 캐시가 있다.    

- 개인 전용 캐시     
개인전용캐시는 사용자의 웹 브라우저에 의해서 관리되며, 웹 브라우저에 저장된다. 

- 공용 캐시(캐시 프락시 서버)     
공용 캐시(혹은 캐시 프락시 서버라고 불린다.) 공용캐시는 클라이언트와 서버 사이에 위치하여 클라이언트의 요청에 대응되는 캐시 문서가 있는지 우선 확인한다.
공용캐시는 여러사용자가 접근하기때문에, 불필요한 트래픽을 줄일수있는 더 많은 기회가 있다.

--- 
#### 캐시 적중, 재검사, 부적중
캐시는 많은 이점이 있지만, 캐시된 문서가 클라이언트에게 제공하기에 충분히 신선한가 판단하는기준은 모호하다.   
캐시(서버)는 원서버에 캐시된 문서가 충분히 신선한지 확인하기위해서, If-Modified-Since 요청을 함께보낸다. 서버에 있는 문서가 이 시간 이후로 수정되었다면, 클라이언트는 원서버 응답을 받을것이다.        

서버는 사용자에게 신선한 문서를 제공해주기 위해서, 재검사와 부적중 과정을 거친다.    
     
- 캐시 적중
캐시 적중은 요청 문서가 캐시에 있고, 이 캐시가 충분히 신선하여 다시 클라이언트에 전달되는 경우다.

- 캐시 재검사
캐시는 있지만, 해당 캐시가 충분히 신선한지 확인하지 못할때 일어난다. 캐시서버는 원서버에 작은 재검사 요청을 보내고, 만약, 원서버에서 해당 캐시에 대해 변경이 없다면, 캐시 만료기한을 증가 시킨다. 이를 재검사 적중이라고 하며, 재검사 부적중시, 원서버는 캐시서버의 캐시를 업데이트하며, 클라이언트는 원서버의 문서를 받게된다.     


캐시를 재검사하거나, 새로운 캐시를 만들때, HTTP프로퍼티를 통해 해당캐시의 유효기간을 설정해줄수있다.
(유효기간이 만료되어도 사라지는것이 아닌, 서버와 재검사를 해야한다는 의미임을 주의하자)
```HTTP
Cache-Control: max-age=12345(초 단위이다)
```

- 캐시 부적중
캐시에 대응되는 캐시문서가 없다면, 원 서버로 요청을 전달한다.

---
#### Cache-Control, ETag와 If-Modified-Since 헤더
캐싱 헤더는 강한헤더와 약한헤더 두가지가 있다.   
강한헤더란, 캐시가 언제까지 유요한지 명시적으로 지정하여, 이후에는 무조건 파일 재요청을 하도록 한다.   
- Expires, Cache-Conrol max-age가 있다.
   
약한헤더란, 브라우저가 매우 작은 GET요청을 날려, 캐시파일의 변경유무를 확인하고 변경되었을대만 새로운 리소스를 재 요청한다.     
- ETags, If-Modified-Since가 있다.
   
##### Cache-Control과 Expires
Cache-Control헤더는 5가지 지시자가 있다.
- private : 리소스를 브라우저에서만 캐시하며, 프록시 서버에서는 캐시할수없다.
- public : 브라우저, 프록시서버 모두 리소스를 캐시할 수 있다.
- no-store : 리소스를 캐시하여 메모리에 저장하나, 디스크에는 저장하지 않는다.
- no-cache : 리소스를 캐시하지않는다.
- max-age : 캐시의 유효기간을 정의한다. 시간은 초 단위이다.

예시는 아래와 같다.
```HTTP
HTTP/1.1 200 OK
...
Cache-Control : private, max-age = 60
...
```
Expires는 캐시의 만료를 뜻하며 OO날짜 이후에 캐시가 만료됨을 나타낸다. Cache-Control와 동시에 사용할경우 무시된다.     
예시는 아래와 같다.
```HTTP
Expires: Wed, 21 Oct 2015 07:28:00 GMT
```

##### ETag와 If-Modified-Since
원 리소스가 변경되지 않은 상황에서 캐시 만료기간이 다 되어 리소스 전체를 재요청 하는것은 비효율적이다.    
HTTP는 ETag와 If-Modified-Since헤더를 이용해, 캐시 리소스의 수명이 다 되었을경우, 원 서버에 매우 작은 변경확인 GET요청을 날려 원 서버의 리소스가 변경되었을 경우만 리소스를 재요청하는 캐싱기법을 제공한다.     
플로우는 아래와 같다.     
1. 클라이언트는 리소스를 요청한다.
2. 서버는 리소스를 응답하며, ETag헤더를 함께보낸다.
```HTTP
HTTP/1.1 200 OK
...
Cache-Control : max-age = 3600
ETag : "some_value"
...
```     
3. 클라이언트는 다음 요청마다. If-None-Match헤더에 2번에서 전달받은 값을 응답한다.
4. 서버는 변경되지 않았다면 304 NotModified, 변경되었다면 새로운 ETag를 발급하며 200 OK를 전달한다.
   
If-Modified-Sine는 ETag와 달리, 캐시된 사본의 원본 리소스가 OO 날짜 이후에 변경되었다면 200OK와 함께 변경된 리소스를 전달한다. 마찬가지로 변경되지않았다면, 304 NotModified를 응답한다.     
예시는 아래와 같다. (만약 서버가 ETag를 사용한다면 중복되며, If-None-Match 헤더와 중복해서 사용한다면 If-None-Match헤더는 무시된다.)     
```HTTP 
...
If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT
...
```

캐시를 설정할때, ETag와 If-Modified-Sine 둘중 하나만 사용하는것이 좋다. 둘 다 사용할경우, 한쪽은 무시될수있으며, 중복이 발생한다. (Expires와 Cache-Control또한 마찬가지다.)
